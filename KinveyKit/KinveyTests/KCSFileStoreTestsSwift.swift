//
//  KCSFileStoreTestsSwift.swift
//  KinveyKit
//
//  Created by Victor Barros on 2015-07-10.
//  Copyright (c) 2015 Kinvey. All rights reserved.
//

import UIKit
import XCTest

class KCSFileStoreTestsSwift: XCTestCase {
    
    var file: KCSFile? = nil

    override func setUp() {
        super.setUp()
        
        KCSClient.sharedClient().initializeKinveyServiceForAppKey(
            "kid_-1WAs8Rh2",
            withAppSecret: "2f355bfaa8cb4f7299e914e8e85d8c98",
            usingOptions: nil
        )
        
        weak var expectationLogin = expectationWithDescription("login")
        
        KCSUser.createAutogeneratedUser(
            nil,
            completion: { (user: KCSUser!, error: NSError!, actionResult: KCSUserActionResult) -> Void in
                XCTAssertNil(error)
                XCTAssertNotNil(user)
                
                expectationLogin?.fulfill()
        })
        
        waitForExpectationsWithTimeout(30, handler: nil)
    }
    
    override func tearDown() {
        KCSUser.activeUser()?.logout()
        
        super.tearDown()
    }
    
    func upload() {
        weak var expectationUpload = expectationWithDescription("upload")
        
        let url = NSBundle(forClass: self.dynamicType).URLForResource("mavericks", withExtension: "jpg")
        KCSFileStore.uploadFile(
            url,
            options: nil,
            completionBlock: { (file: KCSFile!, error: NSError!) -> Void in
                self.file = file
                
                XCTAssertNil(error)
                XCTAssertNotNil(file)
                
                if let file = file {
                    XCTAssertEqual("https", file.remoteURL.scheme!)
                }
                
                XCTAssertTrue(NSThread.isMainThread())
                
                expectationUpload?.fulfill()
            },
            progressBlock: nil
        )
        
        waitForExpectationsWithTimeout(60, handler: nil)
    }

    func testUpload() {
        upload()
    }
    
    func testUploadMemoryLeak() {
        weak var expectationUpload = expectationWithDescription("upload")
        
        XCTAssertEqual(0, KCSFile.referenceCount())
        XCTAssertEqual(0, KCSNSURLSessionFileOperation.referenceCount())
        
        let url = NSBundle(forClass: self.dynamicType).URLForResource("mavericks", withExtension: "jpg")
        KCSFileStore.uploadFile(
            url,
            options: nil,
            completionBlock: { (file: KCSFile!, error: NSError!) -> Void in
                XCTAssertEqual(1, KCSFile.referenceCount())
                XCTAssertEqual(1, KCSNSURLSessionFileOperation.referenceCount())
                
                expectationUpload?.fulfill()
            },
            progressBlock: nil
        )
        
        waitForExpectationsWithTimeout(60, handler: nil)
        
        weak var expectationMemory = expectationWithDescription("memory")
        
        let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)
        var block: (() -> ())! = nil
        block = { () -> Void in
            if (KCSFile.referenceCount() == 0 && KCSNSURLSessionFileOperation.referenceCount() == 0) {
                expectationMemory?.fulfill()
            } else {
                dispatch_async(queue, block)
            }
        }
        dispatch_async(queue, block)
        
        waitForExpectationsWithTimeout(10, handler: nil)
        
        XCTAssertEqual(0, KCSFile.referenceCount())
        XCTAssertEqual(0, KCSNSURLSessionFileOperation.referenceCount())
    }
    
    func testDownloadByQuery() {
        upload()
        
        weak var expectationDownload = expectationWithDescription("download")
        
        KCSFileStore.downloadFileByQuery(
            KCSQuery(),
            completionBlock: { (results: [AnyObject]!, error: NSError!) -> Void in
                XCTAssertNil(error)
                XCTAssertNotNil(results)
                
                if let results = results {
                    XCTAssertGreaterThan(results.count, 0)
                    for file in results as! [KCSFile] {
                        XCTAssertEqual("https", file.remoteURL.scheme!)
                    }
                }
                
                XCTAssertTrue(NSThread.isMainThread())
                
                expectationDownload?.fulfill()
            },
            progressBlock: nil
        )
        
        waitForExpectationsWithTimeout(60, handler: nil)
    }
    
    func testDownloadByQuery2() {
        upload()
        
        weak var expectationDownload = expectationWithDescription("download")
        
        KCSFileStore.downloadFileByQuery(
            KCSQuery(onField: "_filename", withExactMatchForValue: "mavericks.jpg"),
            completionBlock: { (results: [AnyObject]!, error: NSError!) -> Void in
                XCTAssertNil(error)
                XCTAssertNotNil(results)
                
                if let results = results {
                    XCTAssertGreaterThan(results.count, 0)
                    for file in results as! [KCSFile] {
                        XCTAssertEqual("https", file.remoteURL.scheme!)
                    }
                }
                
                XCTAssertTrue(NSThread.isMainThread())
                
                expectationDownload?.fulfill()
            },
            progressBlock: nil
        )
        
        waitForExpectationsWithTimeout(60, handler: nil)
    }
    
    func testDownloadByName() {
        upload()
        
        weak var expectationDownload = expectationWithDescription("download")
        
        KCSFileStore.downloadFileByName(
            "mavericks.jpg",
            completionBlock: { (results: [AnyObject]!, error: NSError!) -> Void in
                XCTAssertNil(error)
                XCTAssertNotNil(results)
                
                if let results = results {
                    XCTAssertGreaterThan(results.count, 0)
                    for file in results as! [KCSFile] {
                        XCTAssertEqual("https", file.remoteURL.scheme!)
                    }
                }
                
                XCTAssertTrue(NSThread.isMainThread())
                
                expectationDownload?.fulfill()
            },
            progressBlock: nil
        )
        
        waitForExpectationsWithTimeout(60, handler: nil)
    }
    
    func testDownloadFile() {
        upload()
        
        XCTAssertNotNil(file)
        
        if let file = file {
            weak var expectationDownload = expectationWithDescription("download")
            
            KCSFileStore.downloadFile(
                file.fileId,
                options: [KCSFileOnlyIfNewer : true],
                completionBlock: { (results: [AnyObject]!, error: NSError!) -> Void in
                    XCTAssertNil(error)
                    XCTAssertNotNil(results)
                    if let results = results {
                        XCTAssertGreaterThan(results.count, 0)
                        
                        for file in results as! [KCSFile] {
                            XCTAssertEqual("https", file.remoteURL.scheme!)
                        }
                    }
                    
                    XCTAssertTrue(NSThread.isMainThread())
                    
                    expectationDownload?.fulfill()
                },
                progressBlock: nil
            )
            
            waitForExpectationsWithTimeout(60, handler: nil)
        }
    }

}
