//
//  KCSUser2+KinveyUserService.m
//  KinveyKit
//
//  Created by Michael Katz on 12/10/13.
//  Copyright (c) 2013-2014 Kinvey. All rights reserved.
//
// This software is licensed to you under the Kinvey terms of service located at
// http://www.kinvey.com/terms-of-use. By downloading, accessing and/or using this
// software, you hereby accept such terms of service  (and any agreement referenced
// therein) and agree that you have read, understand and agree to be bound by such
// terms of service and are of legal age to agree to such terms with Kinvey.
//
// This software contains valuable confidential and proprietary information of
// KINVEY, INC and is subject to applicable licensing agreements.
// Unauthorized reproduction, transmission or distribution of this file and its
// contents is a violation of applicable laws.
//

#import "KCSUser2+KinveyUserService.h"

#import "KinveyCoreInternal.h"
#import "KinveyDataStoreInternal.h"

KK2(Cleanup!)
#import "KinveyUser.h"
#import "KCSHiddenMethods.h"
#import "KCSDataModel.h"
#import "KCSPush.h"

#define KCSEntityKeyKMD @"_kmd"
#define KCSEntityKeyAuthtoken @"authtoken"
#define KCSEntityKeyEmailVerification @"emailVerification"
#define KCSUserAttributePassword @"password"

@implementation KCSUser2 (KinveyUserService)

#pragma mark - Credential Management

+ (BOOL) hasSavedCredentials
{
    return [KCSKeychain2 hasTokens];
}

+ (BOOL) clearSavedCredentials
{
    return [KCSKeychain2 deleteTokens];
}

+ (void) setActive:(id<KCSUser2>)user
{
    KK2(manage active user here)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"
    [KCSClient sharedClient].currentUser = (id)user;
#pragma clang diagnostic pop
}

+ (id<KCSUser2>)activeUser
{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"
    return (id)[KCSClient sharedClient].currentUser;
#pragma clang diagnostic pop
}

#pragma mark - User Creation

+ (void) createAutogeneratedUser:(NSDictionary *)fieldsAndValues completion:(KCSUser2CompletionBlock)completionBlock
{
    [self createUserWithUsername:nil password:nil fieldsAndValues:fieldsAndValues completion:completionBlock];
}

+ (void) createUserWithUsername:(NSString *)username password:(NSString *)password fieldsAndValues:(NSDictionary *)fieldsAndValues completion:(KCSUser2CompletionBlock)completionBlock
{
    if (!completionBlock) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"Completion Block is nil" userInfo:nil] raise];
    if ((password == nil && username != nil) || (username == nil && password != nil)) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"Both username and password need to be set or both nil" userInfo:nil] raise];
    }
    
    NSMutableDictionary* createUserBody = [NSMutableDictionary dictionaryWithDictionary:fieldsAndValues];
    if (username && password) {
        createUserBody[KCSUserAttributeUsername] = username;
        createUserBody[KCSUserAttributePassword] = password;
    }
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock(nil, error);
            });
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.body = createUserBody;
    request.method = KCSRESTMethodPOST;
    [request start];
}

+ (void) createWithAuthProvider:(KCSUserSocialIdentifyProvider)provider loginBody:(NSDictionary*)body completion:(KCSUser2CompletionBlock)completionBlock;
{
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock(nil, error);
            });
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.body = body;
    [request start];
}


#pragma mark - Login
+ (void)loginWithUsername:(NSString *)username password:(NSString *)password completion:(KCSUser2CompletionBlock)completionBlock
{
    if (!username) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"username should not be nil." userInfo:nil] raise];
    if (!password) [[NSException exceptionWithName:NSInvalidArgumentException reason:@"password should not be nil." userInfo:nil] raise];
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
            [self setActive:nil];
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock(nil, error);
            });
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.path = @[@"login"];
    request.method = KCSRESTMethodPOST;
    request.body = @{@"username":username, @"password":password};
    [request start];
}

+ (void)connectWithAuthProvider:(KCSUserSocialIdentifyProvider)provider accessDictionary:(NSDictionary*)accessDictionary completion:(KCSUser2CompletionBlock)completionBlock
{
    NSDictionary* loginDict = [self loginDictForProvider:provider accessDictionary:accessDictionary];
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            if (response.isKCSError == YES && response.code == KCSNotFoundError) {
                //This is new user, create
                [self createWithAuthProvider:provider loginBody:loginDict completion:completionBlock];
            } else {
                KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
                [self setActive:nil];
                dispatch_async(dispatch_get_main_queue(), ^{
                    completionBlock(nil, error);
                });
            }
        } else {
            // Ok, we're really auth'd
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.path = @[@"login"];
    request.method = KCSRESTMethodPOST;
    request.body = loginDict;
    [request start];
}

+ (NSDictionary*) loginDictForProvider:(KCSUserSocialIdentifyProvider)provder accessDictionary:(NSDictionary*)accessDictionary
{
    NSDictionary* dict = @{};
    NSString* accessToken = [accessDictionary objectForKey:KCSUserAccessTokenKey];
    NSString* accessTokenSecret = [accessDictionary objectForKey:KCSUserAccessTokenSecretKey];
    switch (provder) {
        case KCSSocialIDFacebook: {
            NSString* appId = [accessDictionary objectForKey:KCS_FACEBOOK_APP_KEY];
            if (appId == nil) {
                appId = [[KCSClient sharedClient].options objectForKey:KCS_FACEBOOK_APP_KEY];
                if (appId == nil) {
                    appId = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"FacebookAppID"];
                    if (appId == nil) {
                        // could not locate in the access dictionary, client, or plist, error
                        KCSLogWarn(KCS_LOG_CONTEXT_USER, @"No Facebook App Id provided in access dictionary, or KCSClient options key");
                        DBAssert(appId != nil, @"No Facebook App Id provided");
                    }
                }
            }
            dict = appId != nil ?  @{@"_socialIdentity" : @{@"facebook" : @{@"access_token" : accessToken, @"appid" : appId}}} :
            @{@"_socialIdentity" : @{@"facebook" : @{@"access_token" : accessToken}}};
        }
            break;
        case KCSSocialIDTwitter: {
            NSString* twitterKey = [[KCSClient sharedClient].options objectForKey:KCS_TWITTER_CLIENT_KEY];
            NSString* twitterSecret = [[KCSClient sharedClient].options objectForKey:KCS_TWITTER_CLIENT_SECRET];
            DBAssert(twitterKey != nil && twitterSecret != nil, @"twitter info should not be nil.");
            if (twitterKey != nil && twitterSecret != nil) {
                dict = @{@"_socialIdentity" : @{@"twitter" : @{@"access_token" : accessToken,
                                                               @"access_token_secret" : accessTokenSecret,
                                                               @"consumer_key" : twitterKey,
                                                               @"consumer_secret" : twitterSecret}}};
            }
        }
            break;
        case KCSSocialIDLinkedIn: {
            NSString* linkedInKey = [[KCSClient sharedClient].options objectForKey:KCS_LINKEDIN_API_KEY];
            NSString* linkedInSecret = [[KCSClient sharedClient].options objectForKey:KCS_LINKEDIN_SECRET_KEY];
            DBAssert(linkedInKey != nil && linkedInSecret != nil, @"LinkedIn info should not be nil.");
            if (linkedInKey != nil && linkedInSecret != nil) {
                dict = @{@"_socialIdentity" : @{@"linkedIn" : @{@"access_token" : accessToken,
                                                                @"access_token_secret" : accessTokenSecret,
                                                                @"consumer_key" : linkedInKey,
                                                                @"consumer_secret" : linkedInSecret}}};
            }
        }
            break;
        case KCSSocialIDSalesforce: {
            NSString* idUrl = [accessDictionary objectForKey:KCS_SALESFORCE_IDENTITY_URL];
            NSString* refreshToken = [accessDictionary objectForKey:KCS_SALESFORCE_REFRESH_TOKEN];
            NSString* clientId = [accessDictionary objectForKey:KCS_SALESFORCE_CLIENT_ID];
            if (clientId == nil) {
                clientId = [[KCSClient sharedClient].options objectForKey:KCS_SALESFORCE_CLIENT_ID];
            }
            DBAssert(idUrl != nil, @"salesForce info should not be nil.");
            if (idUrl != nil && accessToken != nil) {
                dict = @{@"_socialIdentity" : @{@"salesforce" : @{@"access_token" : accessToken,
                                                                  KCS_SALESFORCE_IDENTITY_URL : idUrl,
                                                                  KCS_SALESFORCE_REFRESH_TOKEN: refreshToken,
                                                                  KCS_SALESFORCE_CLIENT_ID : clientId}}};
            }
            
        }
            break;
        default:
            dict = accessDictionary;
    }
    return dict;
}

#pragma mark - Logout

+ (void) logoutUser:(id<KCSUser2>)user
{
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to log out a user who is not the KCS Current User!");
    } else {
        
        // Extract all of the items from the Array into a set, so adding the "new" device token does
        // the right thing.  This might be less efficient than just iterating, but these routines have
        // been optimized, we do this now, since there's no other place guarenteed to merge.
        // Login/create store this info
        
        //TODO: comment out to keep the user from being f'ed up. Reinstate once working on the server-side.
        //        KCSDevice *sp = [KCSDevice currentDevice];
        //
        //        if (sp.deviceToken != nil){
        //            NSMutableSet *tmpSet = [NSMutableSet setWithArray:self.deviceTokens];
        //            [tmpSet removeObject:[sp deviceTokenString]];
        //            self.deviceTokens = [tmpSet allObjects];
        //            [self saveToCollection:[KCSCollection userCollection] withCompletionBlock:^(NSArray *objectsOrNil, NSError *errorOrNil) {
        //                if (errorOrNil) {
        //                    KCSLogError(@"Error saving user when removing device tokens: %@", errorOrNil);
        //                }
        //            } withProgressBlock:nil];
        //        }
        [[KCSPush sharedPush] setDeviceToken:nil];
        
        [KCSUser2 clearSavedCredentials];
        [[KCSAppdataStore caches] clear];
        [KCSFileStore clearCachedFiles];
        
        // Set the currentUser to nil
        [self setActive:nil];
    }
}

#pragma mark - User Object Management
+ (void) setupActiveUser:(NSDictionary*)body completion:(KCSUser2CompletionBlock)completionBlock checkAuth:(BOOL) checkAuth
{
    if (![body isKindOfClass:[NSDictionary class]]) {
        //check data type in case server is corrupted, yes this has happened
        NSError* error = [NSError createKCSError:@"Entity dictionary not returned for user" code:401 userInfo:@{@"body":body}];
        completionBlock(nil, error);
        return;
    }
    
    NSString* userId = body[KCSEntityKeyId];
    NSString* username = body [KCSUserAttributeUsername];
    if (userId == nil || username == nil) {
        //prevent that weird assertion that Colden was seeing
        NSError* error = [NSError createKCSError:@"Entity dictionary does not have username or user id" code:401 userInfo:@{@"body":body}];
        completionBlock(nil, error);
        return;
    }
    
    //Strip token
    NSMutableDictionary* modifiedProperties = [body mutableCopy];
    [modifiedProperties removeObjectForKey:KCSUserAttributePassword]; //discard the password in all cases
    
    NSMutableDictionary* metadata = [NSMutableDictionary dictionaryWithDictionary:modifiedProperties[KCSEntityKeyKMD]];
    
    NSString* authToken = nil;
    if (checkAuth) {
        authToken = [metadata popObjectForKey:KCSEntityKeyAuthtoken];
        
        if (authToken == nil) {
            NSError* error = [NSError createKCSError:@"Entity dictionary does not contain an auth token" code:401 userInfo:@{@"body":body}];
            completionBlock(nil, error);
            return;
        }
    }
    
    //Handle Email Verification
    NSDictionary* emailVerification = [metadata popObjectForKey:KCSEntityKeyEmailVerification];
    NSString* verificationStatus = [emailVerification objectForKey:@"status"];
    
    //Put the updated properties back
    modifiedProperties[KCSEntityKeyMetadata] = metadata;
    
    //Make the user object
    KCSCollection* userCollection = [KCSCollection userCollection];
    id<KCSUser2> user = (id<KCSUser2>) [[KCSAppdataStore caches].dataModel objectFromCollection:userCollection.collectionName data:modifiedProperties];
    user.emailVerified = [verificationStatus isEqualToString:@"confirmed"];
    
    if (user.userId == nil || user.username == nil) {
        //prevent that weird assertion that Colden was seeing
        NSError* error = [NSError createKCSError:@"User object not properly configured with _id and username" code:401 userInfo:@{@"body":body}];
        completionBlock(nil, error);
        return;
    }
    
    if (checkAuth) {
        [KCSKeychain2 setKinveyToken:authToken user:userId];
    }
    [self setActive:user];
    [[KCSAppdataStore caches] cacheActiveUser:user];
    
    [[KCSPush sharedPush] registerDeviceToken:^(BOOL success, NSError *error) {
        dispatch_async(dispatch_get_main_queue(), ^{
            completionBlock(user, error);
        });
    }];
}

+ (void)changePasswordForUser:(id<KCSUser2>)user password:(NSString*)newPassword completion:(KCSUser2CompletionBlock)completionBlock
{
    if (newPassword == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"newPassword is nil" userInfo:nil] raise];
    }
    if (![user isEqual:[KCSUser activeUser]]){
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Receiver is not current user.",
                                   NSLocalizedFailureReasonErrorKey: @"An operation only applicable to the current user was tried on a different user.",
                                   NSLocalizedRecoverySuggestionErrorKey:@"Only perform this action on the active user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        completionBlock(nil, userError);
    } else {
        KCSCollection* userCollection = [KCSCollection userCollection];
        NSDictionary* entity = [[KCSAppdataStore caches].dataModel jsonEntityForObject:user route:[userCollection route] collection:userCollection.collectionName];
        NSDictionary* body = [entity dictionaryByAddingDictionary:@{KCSUserAttributePassword : newPassword}];
        
        KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
            if (error) {
                KCSLogNSError(KCS_LOG_CONTEXT_USER, error);
                completionBlock(nil, error);
            } else {
                // Ok, we're really auth'd
                NSDictionary* userBody = [response jsonObject];
                [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
            }
            
        }
                                                            route:KCSRESTRouteUser
                                                          options:@{KCSRequestLogMethod}
                                                      credentials:[KCSUser activeUser]];
        request.method = KCSRESTMethodPUT;
        request.path = @[user.userId];
        request.body = body;
        [request start];
    }
}

+ (void) refreshUser:(id<KCSUser2>)user options:(NSDictionary*)options completion:(KCSUser2CompletionBlock)completionBlock
{
    //options to use in the future for loading references, etc
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to refresh a user who is not the KinveyKit Active User!");
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"User refresh is not on active user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        completionBlock(nil, userError);
        return;
    }
    if (user.userId == nil) {
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Error refreshing user, no user id.");
        NSDictionary* errorInfo =  @{NSLocalizedDescriptionKey:@"User has no _id."};
        NSError* error = [NSError createKCSError:KCSUserErrorDomain code:KCSUserObjectNotActiveError userInfo:errorInfo];
        completionBlock(nil, error);
        return;
    }
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogError(KCS_LOG_CONTEXT_USER, @"Error Updating user: %@", error);
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock(user, error);
            });
        } else {
            if ([KCSUser activeUser] != user) { // still have to check here because active user can be reset while loading request
                KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to refresh a user who is not the KinveyKit Active User!");
                NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"User refresh is not on active user"};
                NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
                dispatch_async(dispatch_get_main_queue(), ^{
                    completionBlock(user, userError);
                });
            } else {
                NSDictionary* userBody = [response jsonObject];
                [self setupActiveUser:userBody completion:completionBlock checkAuth:NO];
            }
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:user];
    request.path = @[user.userId];
    [request start];
}

+ (void) saveUser:(id<KCSUser2>)user options:(NSDictionary*)options completion:(KCSUser2CompletionBlock)completionBlock
{
    //options for future with references and such
    
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to save a user who is not the KinveyKit Active User!");
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Receiver is not current user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        completionBlock(nil, userError);
        return;
    }
    if (user.userId == nil) {
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Error save user, no user id.");
        NSDictionary* errorInfo =  @{NSLocalizedDescriptionKey:@"User object save needs and established user."};
        NSError* error = [NSError createKCSError:KCSUserErrorDomain code:KCSUserObjectNotActiveError userInfo:errorInfo];
        completionBlock(nil, error);
        return;
    }
    
    NSDictionary* entity = [[KCSAppdataStore caches].dataModel jsonEntityForObject:user route:KCSRESTRouteUser collection:KCSUserCollectionName];
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error) {
            KCSLogError(KCS_LOG_CONTEXT_USER, @"Error Updating user: %@", error);
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock(user, error);
            });
        } else {
            NSDictionary* userBody = [response jsonObject];
            [self setupActiveUser:userBody completion:completionBlock checkAuth:YES];
        }
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:user];
    request.method = KCSRESTMethodPUT;
    request.path = @[user.userId];
    request.body = entity;
    [request start];
}

+ (void) deleteUser:(id<KCSUser2>)user options:(NSDictionary*)options completion:(KCSCountBlock)completionBlock
{
    if (![user isEqual:[KCSUser activeUser]]){
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Attempted to delete a user who is not the KinveyKit Active User!");
        NSDictionary *userInfo = @{NSLocalizedDescriptionKey: @"Receiver is not current user"};
        NSError *userError = [NSError createKCSError:KCSUserErrorDomain code:KCSOperationRequiresCurrentUserError userInfo:userInfo];
        completionBlock(0, userError);
        return;
    }
    if (user.userId == nil) {
        KCSLogError(KCS_LOG_CONTEXT_USER, @"Error delete user, no user id.");
        NSDictionary* errorInfo =  @{NSLocalizedDescriptionKey:@"User object delete needs and established user."};
        NSError* error = [NSError createKCSError:KCSUserErrorDomain code:KCSUserObjectNotActiveError userInfo:errorInfo];
        completionBlock(0, error);
        return;
    }
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        if (error != nil) {
            [self logoutUser:user];
        }
        completionBlock(error != nil, error);
    }
                                                        route:KCSRESTRouteUser
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:user];
    request.method = KCSRESTMethodDELETE;
    request.path = @[user.userId];
    [request start];
}

+ (void) sendPasswordResetForUsername:(NSString*)username completion:(KCSUserSendEmailBlock)completionBlock
{
    // /rpc/:kid/:username/user-password-reset-initiate
    // /rpc/:kid/:email/user-password-reset-initiaxte
    if (username == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"username cannot be nil" userInfo:nil] raise];
    }
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[username, @"user-password-reset-initiate"];
    [request start];
}

+ (void) sendPasswordResetForEmail:(NSString*)email completion:(KCSUserSendEmailBlock)completionBlock
{
    // /rpc/:kid/:email/user-password-reset-initiate
    if (email == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"email cannot be nil" userInfo:nil] raise];
    }
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[email, @"user-password-reset-initiate"];
    [request start];
}

+ (void) sendEmailConfirmationForUser:(NSString*)username completion:(KCSUserSendEmailBlock)completionBlock
{
    //req.post /rpc/:kid/:username/user-email-verification-initiate
    if (username == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"username cannot be nil" userInfo:nil] raise];
    }
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[username, @"user-email-verification-initiate"];
    [request start];
}

+ (void) sendForgotUsernameEmail:(NSString*)email completion:(KCSUserSendEmailBlock)completionBlock
{
    if (email == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"email cannot be nil" userInfo:nil] raise];
    }
    
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        completionBlock(response.code == KCS_HTTP_STATUS_NO_CONTENT, error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[@"user-forgot-username"];
    request.body = @{@"email" : email};
    [request start];
}

+ (void) checkUsername:(NSString*)potentialUsername completion:(KCSUserCheckUsernameBlock)completionBlock
{
    if (potentialUsername == nil) {
        [[NSException exceptionWithName:NSInvalidArgumentException reason:@"potentialUsername cannot be nil" userInfo:nil] raise];
    }
    
    // /rpc/:appKey/check-username-exists
    KCSRequest2* request = [KCSRequest2 requestWithCompletion:^(KCSNetworkResponse *response, NSError *error) {
        //response will be a 204 if accepted by server
        NSDictionary* dict = [response jsonObject];
        completionBlock(potentialUsername, [dict[@"usernameExists"] boolValue], error);
    }
                                                        route:KCSRESTRouteRPC
                                                      options:@{KCSRequestLogMethod}
                                                  credentials:[KCSClient2 sharedClient]];
    request.method = KCSRESTMethodPOST;
    request.path = @[@"check-username-exists"];
    request.body = @{@"username": potentialUsername};
    [request start];
}

@end
