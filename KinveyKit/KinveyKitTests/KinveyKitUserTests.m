//
//  KinveyKitUserTests.m
//  KinveyKit
//
//  Created by Brian Wilson on 1/5/12.
//  Copyright (c) 2012-2013 Kinvey. All rights reserved.
//
// This software is licensed to you under the Kinvey terms of service located at
// http://www.kinvey.com/terms-of-use. By downloading, accessing and/or using this
// software, you hereby accept such terms of service  (and any agreement referenced
// therein) and agree that you have read, understand and agree to be bound by such
// terms of service and are of legal age to agree to such terms with Kinvey.
//
// This software contains valuable confidential and proprietary information of
// KINVEY, INC and is subject to applicable licensing agreements.
// Unauthorized reproduction, transmission or distribution of this file and its
// contents is a violation of applicable laws.
//


#import "KinveyKitUserTests.h"
#import "KinveyUser.h"
#import "KCSClient.h"
#import "KCSKeyChain.h"
#import "KCSConnectionPool.h"
#import "KCSMockConnection.h"
#import "KCSConnectionResponse.h"
#import "KinveyHTTPStatusCodes.h"
#import "KCS_SBJson.h"
#import "KinveyPing.h"
#import "KCSLogManager.h"
#import "KCSAuthCredential.h"
#import "KCSRESTRequest.h"
#import "KinveyCollection.h"
#import "NSString+KinveyAdditions.h"
#import "KCSObjectMapper.h"

#import "TestUtils.h"

typedef BOOL(^KCSUserSuccessAction)(KCSUser *, KCSUserActionResult);
typedef BOOL(^KCSUserFailureAction)(KCSUser *, NSError *);
typedef BOOL(^KCSEntitySuccessAction)(id, NSObject *);
typedef BOOL(^KCSEntityFailureAction)(id, NSError *);

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated"

@interface KinveyKitUserTests () <KCSUserActionDelegate, KCSEntityDelegate>
@property (nonatomic) BOOL testPassed;
@property (nonatomic, copy) KCSUserSuccessAction onSuccess;
@property (nonatomic, copy) KCSUserFailureAction onFailure;
@property (nonatomic, copy) KCSEntitySuccessAction onEntitySuccess;
@property (nonatomic, copy) KCSEntityFailureAction onEntityFailure;
@property (nonatomic, retain) KCS_SBJsonParser *parser;
@property (nonatomic, retain) KCS_SBJsonWriter *writer;

@end


@implementation KinveyKitUserTests

- (void)setUp
{
    _testPassed = NO;
    _onSuccess = [^(KCSUser *u, KCSUserActionResult result){ return NO; } copy];
    _onFailure = [^(KCSUser *u, NSError *error){ return NO; } copy];
    _onEntitySuccess = [^(id u, NSObject *obj){ return NO; } copy];
    _onEntityFailure = [^(id u, NSError *error){ return NO; } copy];
    [TestUtils justInitServer];

    _parser = [[KCS_SBJsonParser alloc] init];
    _writer = [[KCS_SBJsonWriter alloc] init];
}

- (void)tearDown
{
    [[KCSUser activeUser] logout];
}

- (KCSUser*) currentOrAutogen
{
    if ([KCSUser activeUser] == nil) {
        self.done = NO;
        [KCSUser createAutogeneratedUser:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
            STAssertNoError;
            KTAssertEqualsInt(result, KCSUserCreated, @"should create new user");
            self.done = YES;
        }];
        [self poll];
    }
    KCSUser* user = [KCSUser activeUser];
    STAssertNotNil(user, @"should have active user");
    return user;
}

// These tests are ordered and must be run first, hence the AAAXX

- (void)testAAAAAInitializeCurrentUserInitializesCurrentUserNoNetwork {
    [KCSUser clearSavedCredentials];
    [[KCSUser activeUser] logout];
    
    KCSUser *cUser = [KCSUser activeUser];
    STAssertNil(cUser, @"should have no user");
    STAssertNil(cUser.username, @"uname should start nil");
    STAssertNil(cUser.password, @"pw should start nil");

    // initialize the user in the keychain (make a user that's "logged in")
    [KCSKeyChain setString:@"brian" forKey:@"username"];
    [KCSKeyChain setString:@"12345" forKey:@"password"];
    [KCSKeyChain setString:@"That's the combination for my luggage" forKey:@"_id"];
    
    [KCSUser activeUser];

    cUser = [KCSUser activeUser];
    NSLog(@"Current user passowrd: %@", cUser.password);
    
    STAssertEqualObjects(cUser.username, @"brian", @"uname should match");
    STAssertEqualObjects(cUser.password, @"12345", @"pw should match");
    STAssertEqualObjects(cUser.userId, @"That's the combination for my luggage", @"ids should match");
}

- (void)testAAABBLogoutLogsOutCurrentUser
{
    KCSUser *cUser = [self currentOrAutogen];
    STAssertNotNil(cUser, @"need an active user for this test to work");
    [cUser logout];
    STAssertNil(cUser.username, @"uname should start nil");
    STAssertNil(cUser.password, @"pw should start nil");
}

- (void)testRequestDoesNotCreateImplictUser
{
    [[KCSUser activeUser] logout];
    
    KCSUser *cUser = [KCSUser activeUser];
    STAssertNil(cUser.username, @"uname should start nil");
    STAssertNil(cUser.password, @"pw should start nil");
    
    self.done = NO;
    KCSAppdataStore* store = [KCSAppdataStore storeWithCollection:[KCSCollection collectionFromString:@"foo" ofClass:[NSDictionary class]] options:nil];
    [store queryWithQuery:[KCSQuery query] withCompletionBlock:^(NSArray *objectsOrNil, NSError *errorOrNil) {
        STAssertNil(objectsOrNil, @"no objects");
        STAssertNotNil(errorOrNil, @"should get an error");
        KTAssertEqualsInt(errorOrNil.code, 401, @"should be a no creds");
        STAssertNil([KCSUser activeUser], @"should still have no user");
        
        self.done = YES;
    } withProgressBlock:nil];
    [self poll];
}

//TODO: remove this test point it's no longer needed since PING does not cause a user create should instead try some other request
- (void)noTestAAADDInitializeCurrentUserWithRequestPerformsRequest
{
    [TestUtils justInitServer];
    // Ensure user is logged out
    [[KCSUser activeUser] logout];

    // Create a mock object for the real request
    KCSMockConnection *realRequest = [[KCSMockConnection alloc] init];
    realRequest.connectionShouldFail = NO;
    realRequest.connectionShouldReturnNow = YES;
    realRequest.responseForSuccess = [KCSConnectionResponse connectionResponseWithCode:KCS_HTTP_STATUS_OK
                                                                          responseData:[self.writer dataWithObject:@{}]
                                                                            headerData:nil
                                                                              userData:nil];
    
    // Create a Mock Object for the user request
    KCSMockConnection *connection = [[KCSMockConnection alloc] init];
    
    connection.connectionShouldReturnNow = YES;
    connection.connectionShouldFail = NO;
    
    // Success dictionary
    NSDictionary *dictionary = @{KCSUserAttributeUsername : @"brian", @"password" : @"password", KCSEntityKeyId : @"_id"};
    connection.responseForSuccess = [KCSConnectionResponse connectionResponseWithCode:KCS_HTTP_STATUS_CREATED
                                                                         responseData:[self.writer dataWithObject:dictionary]
                                                                           headerData:nil
                                                                             userData:nil];
    
    [[KCSConnectionPool sharedPool] topPoolsWithConnection:realRequest];
    [[KCSConnectionPool sharedPool] topPoolsWithConnection:connection];
    
    __block BOOL pingWorked = NO;
    __block NSString *description = nil;
    
    // Run the request
    self.done = NO;
    [KCSPing pingKinveyWithBlock:^(KCSPingResult *res){
        pingWorked = res.pingWasSuccessful; 
        description = res.description;
        self.done = YES;
    }];
    [self poll];
    
    // This test CANNOT work with the existing KCS REST framework.  There's a built-in 0.05 second delay that we cannot compensate for here...
    // at the moment...
    STAssertTrue(pingWorked, @"Ping should work");
    STAssertFalse([description containsStringCaseInsensitive:@"brian"], @"username should be in the description");
    
    // Check to make sure the auth worked
    KCSUser *cUser = [KCSUser activeUser];
    STAssertFalse([cUser.username isEqualToString:@"brian"], @"uname should match");
    STAssertFalse([cUser.password isEqualToString:@"12345"], @"pw should match");
    
    // Make sure we log-out
    [cUser logout];
    
    [[KCSConnectionPool sharedPool] drainPools];
}


- (void)testCanCreateArbitraryUser
{
    [[KCSUser activeUser] logout];
    
    NSString *testUsername = @"arbitrary";
    NSString *testPassword = @"54321";
    KCSMockConnection *connection = [[KCSMockConnection alloc] init];
    
    connection.connectionShouldReturnNow = YES;
    connection.connectionShouldFail = NO;
    
    // Success dictionary
    NSDictionary *dictionary = wrapResponseDictionary([NSDictionary dictionaryWithObjectsAndKeys:testUsername, @"username",
                                testPassword, @"password",
                                @"hello", @"_id", nil]);
    
    connection.responseForSuccess = [KCSConnectionResponse connectionResponseWithCode:KCS_HTTP_STATUS_CREATED
                                                                         responseData:[self.writer dataWithObject:dictionary]
                                                                           headerData:nil
                                                                             userData:nil];
    
    [[KCSConnectionPool sharedPool] topPoolsWithConnection:connection];
    
    self.onSuccess = [^(KCSUser *user, KCSUserActionResult result){
        if ([user.username isEqualToString:testUsername] &&
            [user.password isEqualToString:testPassword] &&
            result == KCSUserCreated){
            return YES;
        } else {
            return NO;
        }
    } copy];
    
    [KCSUser userWithUsername:testUsername password:testPassword withDelegate:self];
    STAssertTrue(self.testPassed, @"test should pass");
}

- (void)testCanLoginExistingUser
{
    [[KCSUser activeUser] logout];
    
    NSString *testUsername = @"existing";
    NSString *testPassword = @"56789";
    KCSMockConnection *connection = [[KCSMockConnection alloc] init];
    
    connection.connectionShouldReturnNow = YES;
    connection.connectionShouldFail = NO;
    
    // Success dictionary
    NSDictionary *dictionary = wrapResponseDictionary([NSDictionary dictionaryWithObjectsAndKeys:
                                testPassword, @"password",
                                testUsername, @"password",
                                @"28hjkshafkh982kjh", @"_id", nil]);

    connection.responseForSuccess = [KCSConnectionResponse connectionResponseWithCode:KCS_HTTP_STATUS_OK
                                                                         responseData:[self.writer dataWithObject:dictionary]
                                                                           headerData:nil
                                                                             userData:nil];
    
    [[KCSConnectionPool sharedPool] topPoolsWithConnection:connection];
    
    self.onSuccess = [^(KCSUser *user, KCSUserActionResult result){
        if ([user.username isEqualToString:testUsername] &&
            [user.password isEqualToString:testPassword] &&
            result == KCSUserFound){
            return YES;
        } else {
            return NO;
        }
    } copy];
    
    [KCSUser loginWithUsername:testUsername password:testPassword withDelegate:self];
    
    STAssertTrue(self.testPassed, @"test should pass");
}

- (void)testCanLogoutUser
{
    [[KCSUser activeUser] logout];
    
    [KCSKeyChain setString:@"logout" forKey:@"username"];
    [KCSKeyChain setString:@"98765" forKey:@"password"];
    [KCSKeyChain setString:@"That's the combination for my luggage" forKey:@"_id"];
    [KCSUser activeUser];
    [[KCSUser activeUser] logout];
    
    
    // Check to make sure keychain is clean
    STAssertNil([KCSKeyChain getStringForKey:@"username"], @"username should be clean");
    STAssertNil([KCSKeyChain getStringForKey:@"password"], @"password should be clean");
    STAssertNil([KCSKeyChain getStringForKey:@"_id"], @"_id should be clean");
    
    // Check to make sure user is nil
    STAssertNil([KCSUser activeUser], @"cuser should be nilled");
}

- (void)testAnonymousUser
{
    [[KCSUser activeUser] logout];
    
    STAssertNil([KCSUser activeUser], @"should have no user");
    
    __block NSString* uname = nil;
    self.done = NO;
    [KCSUser createAutogeneratedUser:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
        STAssertNoError;
        STAssertNotNil(user, @"should have a user");
        STAssertEqualObjects(user, [KCSUser activeUser], @"user should be set");
        uname = user.username;
        self.done = YES;
    }];
    [self poll];
    STAssertNotNil([KCSUser activeUser], @"should have an active User");
    
    
    self.done = NO;
    KCSAppdataStore* store = [KCSAppdataStore storeWithCollection:[KCSCollection collectionFromString:@"foo" ofClass:[NSDictionary class]] options:nil];
    [store queryWithQuery:[KCSQuery query] withCompletionBlock:^(NSArray *objectsOrNil, NSError *errorOrNil) {
        STAssertNoError;
        STAssertObjects(0);
        
        STAssertEqualObjects([KCSUser activeUser].username, uname, @"should still be the same anon user");
        self.done = YES;
    } withProgressBlock:nil];
    [self poll];
}

- (void)testCanAddArbitraryDataToUser
{
    [[KCSUser activeUser] logout];
    
    // Make sure we have a user
    if ([KCSUser activeUser] == nil){
        [KCSKeyChain setString:@"brian" forKey:@"username"];
        [KCSKeyChain setString:@"12345" forKey:@"password"];
        [KCSKeyChain setString:@"That's the combination for my luggage" forKey:@"_id"];
        
        [KCSUser activeUser];
    }
    
    KCSUser *currentUser = [KCSUser activeUser];
    
    [currentUser setValue:[NSNumber numberWithInt:32] forAttribute:@"age"];
    [currentUser setValue:@"Brooklyn, NY" forAttribute:@"birthplace"];
    [currentUser setValue:[NSNumber numberWithBool:YES] forAttribute:@"isAlive"];
    
    STAssertEquals((int)[[currentUser getValueForAttribute:@"age"] intValue], (int)32, @"age should match");
    STAssertTrue([[currentUser getValueForAttribute:@"isAlive"] boolValue], @"isAlive should match");
    STAssertEqualObjects([currentUser getValueForAttribute:@"birthplace"], @"Brooklyn, NY", @"birthplace should match");
}

- (void) testComplexAttribute
{
    NSArray* loc = @[@100,@10];
    CLLocation* location = [CLLocation locationFromKinveyValue:loc];
    KCSUser* user = [[KCSUser alloc] init];
    [user setValue:location forAttribute:@"location"];
    
    NSError* errorOrNil = nil;
    KCSSerializedObject* obj = [KCSObjectMapper makeResourceEntityDictionaryFromObject:user forCollection:@"user" error:&errorOrNil];
    STAssertNoError;

    NSDictionary* serialized = obj.dataToSerialize;
    NSArray* objLoc = serialized[@"location"];
    STAssertEqualObjects(loc, objLoc, @"Should get location back properly");
                            
}

- (void) testAutogenUser
{
    [[KCSUser activeUser] logout];
    STAssertNil([KCSUser activeUser], @"start with no user");
    
    KCSUser* u = [self currentOrAutogen];
    STAssertNotNil(u, @"should be active user");
    STAssertNotNil(u.userId, @"should be active user");
    STAssertNotNil(u.username, @"should be active user");
    STAssertNotNil(u.password, @"should be active user");
    STAssertNotNil(u.sessionAuth, @"should be active user");
}

- (void) testInitActive
{
    [[KCSUser activeUser] logout];
    [KCSUser clearSavedCredentials];
    
    KCSUser* user = [KCSUser initAndActivateWithSavedCredentials];
    STAssertNil(user, @"should have a nil user");
    
    [KCSKeyChain setString:@"brian" forKey:@"username"];
    [KCSKeyChain setString:@"12345" forKey:@"password"];
    [KCSKeyChain setString:@"That's the combination for my luggage" forKey:@"_id"];
    
    user = [KCSUser initAndActivateWithSavedCredentials];
    STAssertNotNil(user, @"Should be set by keychain");
    STAssertNotNil(user.username, @"Should be set by keychain");
}

- (void)testCanGetCurrentUser
{
    [[KCSUser activeUser] logout];
    
    
    // Make sure we have a user
    if ([KCSUser activeUser] == nil){
        [KCSKeyChain setString:@"brian" forKey:@"username"];
        [KCSKeyChain setString:@"12345" forKey:@"password"];
        [KCSKeyChain setString:@"That's the combination for my luggage" forKey:@"_id"];
        
        [KCSUser activeUser];
    }
    
    KCSUser *currentUser = [KCSUser activeUser];

    NSString *aKey = @"age";
    int age = 32;
    int age_ = 99;
    NSString *bKey = @"birthplace";
    NSString *bPlace = @"Brooklyn, NY";
    NSString *bPlace_ = @"Long Beach, CA";
    NSString *cKey = @"isAlive";
    BOOL alive = YES;
    BOOL alive_ = NO;

    [currentUser setValue:@(age) forAttribute:aKey];
    [currentUser setValue:bPlace forAttribute:bKey];
    [currentUser setValue:@(alive) forAttribute:cKey];

    // Check prior to fetch
    STAssertEquals((int)[[currentUser getValueForAttribute:aKey] intValue], age, @"age should match");
    STAssertEquals((BOOL)[[currentUser getValueForAttribute:cKey] boolValue], alive, @"isAlive should match");
    STAssertEqualObjects([currentUser getValueForAttribute:bKey], bPlace, @"birthplace should match");

    // Prepare request
    NSDictionary *dictionary = wrapResponseDictionary([NSDictionary dictionaryWithObjectsAndKeys:@"brian", @"username",
                                @"12345", @"password",
                                @"That's the combination for my luggage", @"_id",
                                @(age_), aKey,
                                bPlace_, bKey,
                                @(alive_), cKey, nil]);
    
    KCSMockConnection *connection = [[KCSMockConnection alloc] init];
    
    connection.connectionShouldReturnNow = YES;
    connection.connectionShouldFail = NO;

    connection.responseForSuccess = [KCSConnectionResponse connectionResponseWithCode:KCS_HTTP_STATUS_OK
                                                                         responseData:[self.writer dataWithObject:dictionary]
                                                                           headerData:nil
                                                                             userData:nil];
    
    [[KCSConnectionPool sharedPool] topPoolsWithConnection:connection];

    __block NSDictionary *dict;
    
    self.onEntitySuccess = [^(id e, NSObject *obj){
        dict = (NSDictionary *)obj;
        return YES;
    } copy];

    [[KCSUser activeUser] loadWithDelegate:self];
    
    // Current user is primed
    STAssertEquals((int)[[currentUser getValueForAttribute:aKey] intValue], age_, @"age should match");
    STAssertEquals((BOOL)[[currentUser getValueForAttribute:cKey] boolValue], alive_, @"isAlive should match");
    STAssertEqualObjects([currentUser getValueForAttribute:bKey], bPlace_, @"birthplace should match");
}

- (void) testNeedUsernameAndPassword
{
    STAssertThrowsSpecificNamed([KCSUser userWithUsername:nil password:@"foo" withCompletionBlock:nil], NSException, NSInvalidArgumentException, @"need invalid arg");
    STAssertThrowsSpecificNamed([KCSUser userWithUsername:@"foo" password:nil withCompletionBlock:nil], NSException, NSInvalidArgumentException, @"need invalid arg");
}


- (void)testCanTreatUsersAsCollection
{
    [[KCSUser activeUser] logout];
    
    // Make sure we have a user
    if ([KCSUser activeUser] == nil){
        [KCSKeyChain setString:@"brian" forKey:@"username"];
        [KCSKeyChain setString:@"12345" forKey:@"password"];
        [KCSKeyChain setString:@"That's the combination for my luggage" forKey:@"_id"];
        
        [KCSUser activeUser];
    }
    STAssertTrue([[KCSCollection userCollection] isKindOfClass:[KCSCollection class]], @"user collection should be a collection");
}

- (void)user:(KCSUser *)user actionDidCompleteWithResult:(KCSUserActionResult)result
{
    self.testPassed = self.onSuccess(user, result);
}

- (void)user:(KCSUser *)user actionDidFailWithError:(NSError *)error
{
    self.testPassed = self.onFailure(user, error);
}

- (void)entity:(id<KCSPersistable>)entity fetchDidCompleteWithResult:(NSObject *)result
{
    self.testPassed = self.onEntitySuccess(entity, result);
}

- (void)entity:(id<KCSPersistable>)entity fetchDidFailWithError:(NSError *)error
{
    self.testPassed = self.onEntityFailure(entity, error);
}

- (void)entity:(id)entity operationDidCompleteWithResult:(NSObject *)result
{
    self.testPassed = self.onEntitySuccess(entity, result);
    self.done = YES;
}

- (void)entity:(id)entity operationDidFailWithError:(NSError *)error
{
    self.testPassed = self.onEntityFailure(entity, error);
    self.done = YES;
}


static NSString* lastUser;
static NSString* access_token = @"CAAGI68NkOC4BAB6yYrWF4tlvky3Sxfir4kQcyAobt9WpWt4oNAcFYYaVa8vLdGprVKOyVXKyeb9g5zg7Ldw520JsszFnLER7DlASz30qzZBQ0A0Kpbk0LtPWl6vzyDzwfZCLG05hZC6IHIjqPOp2ZBPmCAL45ZAYZD";

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

- (void) testLoginWithFacebookOld
{
    [TestUtils justInitServer];
    // Ensure user is logged out
    [[KCSUser activeUser] logout];
    self.done = NO;
    [KCSUser loginWithFacebookAccessToken:access_token withCompletionBlock:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
        STAssertNoError;
        STAssertNotNil(user, @"user should not be nil");
        self.done = YES;
    }];
    [self poll];
    
    self.done = NO;
    [KCSPing pingKinveyWithBlock:^(KCSPingResult *result) {
        STAssertTrue(result.pingWasSuccessful, @"should have been a success.");
        self.done = YES;
    }];
    [self poll];
    
    lastUser = [KCSClient sharedClient].currentUser.username;
}

#pragma clang diagnostic pop

- (void) testLoginWithFacebookNew
{
    [TestUtils justInitServer];
    // Ensure user is logged out
    [[KCSUser activeUser] logout];
    self.done = NO;
    [KCSUser loginWithSocialIdentity:KCSSocialIDFacebook accessDictionary:@{KCSUserAccessTokenKey : access_token} withCompletionBlock:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
        STAssertNoError;
        STAssertNotNil(user, @"user should not be nil");
        self.done = YES;
    }];
    [self poll];
    
    self.done = NO;
    [KCSPing pingKinveyWithBlock:^(KCSPingResult *result) {
        STAssertTrue(result.pingWasSuccessful, @"should have been a success.");
        self.done = YES;
    }];
    [self poll];
    
    lastUser = [KCSClient sharedClient].currentUser.username;
}

/* function named this way to follow the login with FB */
//TODO: get this to work in the simulator
#if NEVER
- (void) testLoginWithFacebookPersists
{
    [TestUtils justInitServer];
    
    self.done = NO;
    [KCSPing pingKinveyWithBlock:^(KCSPingResult *result) {
        STAssertTrue(result.pingWasSuccessful, @"should have been a success.");
        STAssertEqualObjects(lastUser, [KCSClient sharedClient].currentUser.username, @"user names should match");
        STAssertNotNil([KCSClient sharedClient].currentUser.sessionAuth, @"should have a valid session token");
        self.done = YES;
    }];
    [self poll];
}
#endif

- (void) testLoginWithTwitter
{
    [TestUtils justInitServer];
    // Ensure user is logged out
    [[KCSUser activeUser] logout];

    self.done = NO;
    [KCSUser loginWithSocialIdentity:KCSSocialIDTwitter accessDictionary:@{@"access_token" : @"823982046-Z0OrwAWQO3Ys2jtGM1k7hDnD6Ty9f54T1JRaDHHi",         @"access_token_secret" : @"3yIDGXVZV67m3G480stFgYk5eHZ7UCOSlOVHxh5RQ3g"}
     withCompletionBlock:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
         STAssertNotNil(user, @"user should not be nil");
         self.done = YES;
     }];
    
    [self poll];
    
    self.done = NO;
    [KCSPing pingKinveyWithBlock:^(KCSPingResult *result) {
        STAssertTrue(result.pingWasSuccessful, @"should have been a success.");
        self.done = YES;
    }];
    [self poll];
    
    lastUser = [KCSClient sharedClient].currentUser.username;
}

- (void) testUserCollection
{
    KCSAppdataStore* store = [KCSAppdataStore storeWithCollection:[KCSCollection userCollection] options:nil];
    self.done = NO;
    [store loadObjectWithID:[KCSUser activeUser].kinveyObjectId withCompletionBlock:^(NSArray *objectsOrNil, NSError *errorOrNil) {
        if(errorOrNil) {
            NSLog(@"Failed to load users... %@", errorOrNil);
        } else {
            NSLog(@"%@", objectsOrNil);
        }
        self.done = YES;
    } withProgressBlock:nil];
    [self poll];
}

#pragma mark - User lifecycle
- (void) testUser
{
    [[KCSUser activeUser] logout];
    
    __block KCSUser* bUser = nil;
    self.done = NO;
    [KCSUser createAutogeneratedUser:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
        STAssertNoError
        STAssertNotNil(user, @"shuld have a user");
        bUser = user;
        
        self.done = YES;
    }];
    [self poll];
    
    KCSCollection* aC = [KCSCollection userCollection];
    aC.objectTemplate = [NSMutableDictionary class];
    KCSAppdataStore* us = [KCSAppdataStore storeWithCollection:aC options:nil];
    
    NSMutableDictionary* ur = [@{KCSEntityKeyId : bUser.userId, @"username" : bUser.username, @"password" : bUser.password} mutableCopy];
    ur[@"TEST_PROP"] = @"TEST_VALUE";
    
    self.done = NO;
    [us saveObject:ur withCompletionBlock:^(NSArray *objectsOrNil, NSError *errorOrNil) {
        STAssertNoError
        self.done = YES;
    } withProgressBlock:nil];
    [self poll];
    
    NSString* savedProp = [[KCSUser activeUser] getValueForAttribute:@"TEST_PROP"];
    STAssertNil(savedProp, @"should not have updated the user");
    
    self.done = NO;
    [[KCSUser activeUser] refreshFromServer:^(NSArray *objectsOrNil, NSError *errorOrNil) {
        STAssertNoError
        STAssertEqualObjects(objectsOrNil[0], [KCSUser activeUser], @"should get back activeUser");
        self.done = YES;
    }];
    [self poll];

    NSString* loadedProp = [[KCSUser activeUser] getValueForAttribute:@"TEST_PROP"];
    STAssertNotNil(loadedProp, @"should have updated the user");

}

#pragma mark - Password reset

- (void) testPasswordReset
{
    //need to use a premade user
    self.done = NO;
    NSString* testUser = @"testino";
    [KCSUser loginWithUsername:testUser password:@"12345" withCompletionBlock:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
        STAssertNoError;
        self.done = YES;
    }];
    [self poll];
        
    self.done = NO;
    [KCSUser sendPasswordResetForUser:testUser withCompletionBlock:^(BOOL emailSent, NSError *errorOrNil) {
        STAssertNoError;
        STAssertTrue(emailSent, @"Should send email");
        self.done = YES;
    }];
    [self poll];
}

- (void) testPasswordResetWithNoEmailDoesNotError
{
    //need to use a premade user
    self.done = NO;
    NSString* testUser = @"testino2";
    [KCSUser loginWithUsername:testUser password:@"12345" withCompletionBlock:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
        STAssertNoError;
        self.done = YES;
    }];
    [self poll];
    
    self.done = NO;
    [KCSUser sendPasswordResetForUser:testUser withCompletionBlock:^(BOOL emailSent, NSError *errorOrNil) {
        STAssertNoError;
        STAssertTrue(emailSent, @"Should have send email, anyway");
        self.done = YES;
    }];
    [self poll];
}

- (void) testPasswordResetWithBadUserEmailDoesNotError
{
    NSString* testUser = @"BADUSER";
    self.done = NO;
    [KCSUser sendPasswordResetForUser:testUser withCompletionBlock:^(BOOL emailSent, NSError *errorOrNil) {
        STAssertNoError;
        STAssertTrue(emailSent, @"Should have send email, anyway");
        self.done = YES;
    }];
    [self poll];

}

- (void) testEscapeUser
{
    NSString* testUser = @"abc . foo@foo.com";
    self.done = NO;
    [KCSUser sendPasswordResetForUser:testUser withCompletionBlock:^(BOOL emailSent, NSError *errorOrNil) {
        STAssertNoError;
        STAssertTrue(emailSent, @"Should have send email, anyway");
        self.done = YES;
    }];
    [self poll];
}

- (void) testSendEmailConfirm
{
    self.done = NO;
    NSString* testUser = @"testino";
    [KCSUser loginWithUsername:testUser password:@"12345" withCompletionBlock:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
        STAssertNoError;
        self.done = YES;
    }];
    [self poll];
    
    self.done = NO;
    [KCSUser sendEmailConfirmationForUser:testUser withCompletionBlock:^(BOOL emailSent, NSError *errorOrNil) {
        STAssertNoError;
        STAssertTrue(emailSent, @"Should send email");
        self.done = YES;
    }];
    [self poll];

}

- (void) testChangePassword
{
    KCSUser* u = [self currentOrAutogen];
    STAssertNotNil(u, @"should have a user");
    NSString* currentPassword = u.password;
    NSString* newPasword = [NSString UUID];
    
    STAssertNotNil(currentPassword, @"current password should not be nil");
    STAssertFalse([currentPassword isEqualToString:newPasword], @"should be old password");
    
    self.done = NO;
    [u changePassword:newPasword completionBlock:^(NSArray *objectsOrNil, NSError *errorOrNil) {
        STAssertNoError;
        STAssertEqualObjects(newPasword, [[KCSUser activeUser] password], @"password should be updated");
        NSString* newKeychainPwd = [KCSKeyChain getStringForKey:@"password"];
        STAssertTrue([newKeychainPwd isEqualToString:newPasword], @"should be old password");
        
        self.done = YES;
    }];
    [self poll];
}

- (void) testForgotUsername
{
    self.done = NO;
    NSString* testUser = @"testino";
    [KCSUser loginWithUsername:testUser password:@"12345" withCompletionBlock:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
        STAssertNoError;
        self.done = YES;
    }];
    [self poll];
    
    self.done = NO;
    [KCSUser sendForgotUsername:[KCSUser activeUser].email withCompletionBlock:^(BOOL emailSent, NSError *errorOrNil) {
        STAssertNoError;
        STAssertTrue(emailSent, @"Should send email");
        self.done = YES;
    }];
    [self poll];
}

#pragma mark - check username
- (void) testCheckUsername
{
    [KCSUser checkUsername:@"not exist" withCompletionBlock:^(NSString *username, BOOL usernameAlreadyTaken, NSError *errorOrNil) {
        STAssertNoError;
        STAssertFalse(usernameAlreadyTaken, @"should not have the user");
        self.done = YES;
    }];
    [self poll];
    
    KCSUser* active = [self currentOrAutogen];
    STAssertNotNil(active, @"Should have a user");
    
    self.done = NO;
    [active saveWithCompletionBlock:^(NSArray *objectsOrNil, NSError *errorOrNil) {
        STAssertNoError;
        self.done = YES;
    }];
    [self poll];

    self.done = NO;
    [KCSUser checkUsername:active.username withCompletionBlock:^(NSString *username, BOOL usernameAlreadyTaken, NSError *errorOrNil) {
        STAssertNoError;
        STAssertTrue(usernameAlreadyTaken, @"should have the user");
        self.done = YES;
    }];
    [self poll];
}
#pragma clang diagnostic pop

#pragma mark - Others
- (void) testUsesSessionAuthCredentials
{
//    //create the user
//    self.done = NO;
//    [KCSUser userWithUsername:@"foo" password:@"bar" withCompletionBlock:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
//        STAssertNoError;
//        self.done = YES;
//    }];
//    [self poll];
//    
    [[KCSUser activeUser] logout];
    
    self.done = NO;
    [KCSUser loginWithUsername:@"foo" password:@"bar" withCompletionBlock:^(KCSUser *user, NSError *errorOrNil, KCSUserActionResult result) {
        STAssertNoError
        STAssertNotNil(user.sessionAuth, @"should have a session token");
        self.done = YES;
    }];
    [self poll];
}

@end
